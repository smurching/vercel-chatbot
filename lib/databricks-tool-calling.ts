import type { LanguageModelV2StreamPart } from '@ai-sdk/provider';
import type { DatabricksStreamPartTransformer } from './databricks-stream-part-transformers';
import { tool } from 'ai';
import z from 'zod';
import type { ChatMessage } from './types';

export const DATABRICKS_TOOL_CALL_ID = 'databricks-tool-call';

export const DATABRICKS_TOOL_DEFINITION = tool({
  name: DATABRICKS_TOOL_CALL_ID,
  description: 'Databricks tool call',
  // The input schema is dynamic since its generated by the model
  inputSchema: z.any(),
  // The function is executed on Databricks
  execute: () => null,
});

/**
 * Stream part types
 */
type DatabricksToolCallStreamPart = {
  INCOMING_TYPE: Extract<LanguageModelV2StreamPart, { type: 'tool-call' }>;
  OUTGOING_TYPE: Extract<LanguageModelV2StreamPart, { type: 'tool-call' }> & {
    toolName: typeof DATABRICKS_TOOL_CALL_ID;
  };
};

type DatabricksToolCallOutputStreamPart = {
  INCOMING_TYPE: {
    type: 'raw';
    rawValue: {
      type: 'response.output_item.done';
      item: {
        type: 'function_call_output';
        call_id: string;
        output: any;
      };
    };
  };
  OUTGOING_TYPE: Extract<LanguageModelV2StreamPart, { type: 'tool-result' }>;
};
export type DatabricksToolStreamPart =
  | DatabricksToolCallStreamPart['OUTGOING_TYPE']
  | DatabricksToolCallOutputStreamPart['OUTGOING_TYPE'];

/**
 * Stream part transformers
 */
export const applyDatabricksToolCallStreamPartTransform: DatabricksStreamPartTransformer<
  DatabricksToolStreamPart | LanguageModelV2StreamPart
> = (parts) => {
  const out = parts.flatMap(
    (part): (DatabricksToolStreamPart | LanguageModelV2StreamPart)[] => {
      if (isToolCallStreamPart(part)) {
        return transformToolCallStreamPart(part);
      }
      if (isToolCallOutputStreamPart(part)) {
        return transformToolCallOutputStreamPart(part);
      }
      return [part];
    },
  );
  return { out };
};

const transformToolCallStreamPart = (
  part: DatabricksToolCallStreamPart['INCOMING_TYPE'],
): DatabricksToolCallStreamPart['OUTGOING_TYPE'][] => [
  {
    ...part,
    toolName: DATABRICKS_TOOL_CALL_ID,
    providerExecuted: true,
    providerMetadata: {
      ...part.providerMetadata,
      originalPart: part,
    },
  },
];
const transformToolCallOutputStreamPart = (
  part: DatabricksToolCallOutputStreamPart['INCOMING_TYPE'],
): DatabricksToolCallOutputStreamPart['OUTGOING_TYPE'][] => [
  {
    type: 'tool-result',
    toolCallId: part.rawValue.item.call_id,
    result: part.rawValue.item.output,
    toolName: DATABRICKS_TOOL_CALL_ID,
  },
];

/**
 * Type guards
 */

// Tool call output is sent as response.output_item.done which Vercel handles as a raw chunk
export const isToolCallOutputStreamPart = (
  part: LanguageModelV2StreamPart,
): part is DatabricksToolCallOutputStreamPart['INCOMING_TYPE'] => {
  if (part.type !== 'raw') return false;
  const rawValue = part.rawValue as any;
  return (
    rawValue?.type === 'response.output_item.done' &&
    rawValue?.item?.type === 'function_call_output'
  );
};

export const isToolCallStreamPart = (
  part: LanguageModelV2StreamPart,
): part is DatabricksToolCallStreamPart['INCOMING_TYPE'] =>
  part.type === 'tool-call';

type ChatMessageParts = ChatMessage['parts'][number];
export const isDatabricksToolCallUIMessagePart = (
  part: ChatMessageParts,
): part is Extract<
  ChatMessageParts,
  { type: `tool-${typeof DATABRICKS_TOOL_CALL_ID}` }
> => part.type === `tool-${DATABRICKS_TOOL_CALL_ID}`;
